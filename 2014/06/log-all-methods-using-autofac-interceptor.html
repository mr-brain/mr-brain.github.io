<h2>log all methods using AutoFac interceptor</h2>
<p>Add references to:</p>
<p>*	Autofac.dll (v3.1.1)
*	Autofac.Extras.DynamicProxy2.dll (v3.0.2)
*	Castle.Core.dll (Castle.Core 3.2.0 for .NETFramework v4.0 Client Profile)</p>
<p>#Create Interceptors#
Interceptors implement the Castle.DynamicProxy.IInterceptor interface. Here's a simple interceptor example that logs method calls including inputs and outputs:</p>
<pre><code>public class LoggerClass : IInterceptor
{
	public void Intercept(IInvocation invocation)
	{
		Console.WriteLine(&quot;Calling method {0} with parameters {1}... &quot;,
			invocation.Method.Name,
			string.Join(&quot;, &quot;, invocation.Arguments.Select(a =&gt; (a ?? &quot;&quot;).ToString()).ToArray()));

		invocation.Proceed();

		Console.WriteLine(&quot;Done: result was {0}.&quot;, invocation.ReturnValue);
	}
}
</code></pre>
<p>#Register Interceptors with Autofac#
Interceptors must be registered with the container. You can register them either as typed services or as named services. If you register them as named services, they must be named IInterceptor registrations.</p>
<p>Which of these you choose depends on how you decide to associate interceptors with the types being intercepted.</p>
<pre><code>// Named registration
builder.Register(c =&gt; new LoggerClass())
       .Named&lt;IInterceptor&gt;(&quot;log-calls&quot;);

// Typed registration
builder.Register(c =&gt; new LoggerClass());
</code></pre>
<p>#Enable Interception on Types#
When you register a type being intercepted, you have to mark the type at registration time so Autofac knows to wire up that interception. You do this using the EnableInterfaceInterceptors() and EnableClassInterceptors() registration extensions.</p>
<pre><code>ContainerBuilder cb = new ContainerBuilder();
cb.RegisterType&lt;SomeType&gt;()
	 .As&lt;ISomeInterface&gt;()
	 .EnableInterfaceInterceptors()
	 .InterceptedBy(typeof(LoggerClass));
cb.Register(c =&gt; new LoggerClass());
</code></pre>
<p>Under the covers, EnableInterfaceInterceptors() creates an interface proxy that performs the interception, while EnableClassInterceptors() dynamically subclasses the target component to perform interception of virtual methods.</p>
<p>Both techniques can be used in conjunction with the assembly scanning support, so you can configure batches of components using the same methods.</p>

